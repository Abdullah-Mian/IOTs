#include "esp_camera.h"
#include <WiFi.h>
#include <WebSocketsClient.h>
#include <ArduinoJson.h>

#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// WiFi credentials
const char* ssid = "Victus";
const char* password = "68986898";

// WebSocket server details - CORRECTED
const char* websocket_host = "192.168.137.1";   
const int websocket_port = 8765;                

// ULTRA-CONSERVATIVE settings to prevent stack overflow
#define FRAME_SIZE FRAMESIZE_96X96    // Smallest possible: 96x96
#define JPEG_QUALITY 25               // Lower quality
#define FB_COUNT 1                    // Single buffer only

WebSocketsClient webSocket;
bool websocket_connected = false;
unsigned long last_frame_time = 0;
const unsigned long FRAME_INTERVAL = 1000;  // Very slow: 1 FPS

// Add watchdog timer reset
void resetWatchdog() {
  esp_task_wdt_reset();
}

void startCamera() {
  Serial.println("ğŸ”§ Initializing camera with ultra-conservative settings...");
  
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 10000000;      // Reduced frequency
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size = FRAME_SIZE;
  config.jpeg_quality = JPEG_QUALITY;
  config.fb_count = FB_COUNT;
  
  // Use DRAM instead of PSRAM for stability
  config.fb_location = CAMERA_FB_IN_DRAM;
  config.grab_mode = CAMERA_GRAB_LATEST;
  
  Serial.println("ğŸ“Š Memory before camera init:");
  Serial.printf("   Free heap: %d bytes\n", ESP.getFreeHeap());
  
  // Try multiple initialization attempts with different settings
  esp_err_t err = ESP_FAIL;
  
  // First attempt - ultra conservative
  Serial.println("ğŸ”„ Attempt 1: 96x96 resolution");
  err = esp_camera_init(&config);
  
  if (err != ESP_OK) {
    Serial.println("âš ï¸ Attempt 1 failed, trying even smaller...");
    config.frame_size = FRAMESIZE_QQVGA;  // 160x120
    config.jpeg_quality = 30;
    config.xclk_freq_hz = 8000000;  // Even slower
    
    Serial.println("ğŸ”„ Attempt 2: QQVGA resolution");
    err = esp_camera_init(&config);
  }
  
  if (err != ESP_OK) {
    Serial.println("âš ï¸ Attempt 2 failed, trying minimal settings...");
    config.frame_size = FRAMESIZE_96X96;
    config.jpeg_quality = 35;
    config.xclk_freq_hz = 5000000;  // Very slow
    config.fb_count = 1;
    
    Serial.println("ğŸ”„ Attempt 3: Minimal settings");
    err = esp_camera_init(&config);
  }
  
  if (err != ESP_OK) {
    Serial.printf("âŒ Camera init failed with error 0x%x\n", err);
    Serial.println("ğŸ”§ Possible solutions:");
    Serial.println("   1. Check camera module connection");
    Serial.println("   2. Power cycle the ESP32-CAM");
    Serial.println("   3. Check if camera ribbon cable is properly seated");
    Serial.println("   4. Try a different camera module");
    
    // Don't halt - continue without camera for WebSocket testing
    Serial.println("âš ï¸ Continuing without camera for WebSocket testing...");
    return;
  }
  
  Serial.println("âœ… Camera initialized successfully!");
  Serial.printf("ğŸ“Š Memory after camera init: %d bytes\n", ESP.getFreeHeap());
  
  // Configure sensor for maximum stability
  sensor_t * s = esp_camera_sensor_get();
  if (s != NULL) {
    s->set_framesize(s, FRAME_SIZE);
    s->set_quality(s, JPEG_QUALITY);
    // Disable all automatic adjustments for stability
    s->set_gain_ctrl(s, 0);
    s->set_exposure_ctrl(s, 0);
    s->set_aec2(s, 0);
    s->set_awb_gain(s, 0);
    s->set_agc_gain(s, 0);
    Serial.println("ğŸ“¸ Camera sensor configured for stability");
  }
}

void webSocketEvent(WStype_t type, uint8_t * payload, size_t length) {
  resetWatchdog();  // Reset watchdog in event handler
  
  switch(type) {
    case WStype_DISCONNECTED:
      Serial.println("âŒ WebSocket Disconnected!");
      websocket_connected = false;
      break;
      
    case WStype_CONNECTED:
      {
        Serial.printf("âœ… WebSocket Connected to: %s\n", payload);
        websocket_connected = true;
        
        DynamicJsonDocument doc(256);
        doc["type"] = "camera_connected";
        doc["device"] = "ESP32-CAM-Safe";
        doc["resolution"] = "96x96";
        doc["fps"] = 1;
        
        String message;
        serializeJson(doc, message);
        webSocket.sendTXT(message);
        break;
      }
      
    case WStype_TEXT:
      Serial.printf("ğŸ“¨ Received: %s\n", payload);
      break;
      
    case WStype_ERROR:
      Serial.printf("âŒ WebSocket Error\n");
      websocket_connected = false;
      break;
      
    default:
      break;
  }
}

void connectToWebSocket() {
  Serial.println("ğŸŒ Connecting to WebSocket server...");
  
  webSocket.begin(websocket_host, websocket_port, "/");
  webSocket.onEvent(webSocketEvent);
  webSocket.setReconnectInterval(5000);
  
  unsigned long start_time = millis();
  while (!websocket_connected && (millis() - start_time < 10000)) {
    webSocket.loop();
    resetWatchdog();
    delay(100);
  }
  
  if (websocket_connected) {
    Serial.println("âœ… WebSocket connected successfully!");
  } else {
    Serial.println("âŒ WebSocket connection timeout");
  }
}

void sendCameraFrame() {
  if (!websocket_connected) return;
  
  unsigned long current_time = millis();
  if (current_time - last_frame_time < FRAME_INTERVAL) return;
  
  // Check if camera is working
  sensor_t * s = esp_camera_sensor_get();
  if (s == NULL) {
    Serial.println("âš ï¸ No camera available - skipping frame");
    return;
  }
  
  // Reset watchdog before camera operation
  resetWatchdog();
  
  // Check available memory before capture
  if (ESP.getFreeHeap() < 15000) {  // Need at least 15KB
    Serial.printf("âš ï¸ Low memory (%d bytes) - skipping frame\n", ESP.getFreeHeap());
    return;
  }
  
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    Serial.println("âŒ Camera capture failed");
    return;
  }
  
  // Limit frame size
  if (fb->len > 10000) {  // Max 10KB frames
    Serial.printf("âš ï¸ Frame too large (%d bytes) - skipping\n", fb->len);
    esp_camera_fb_return(fb);
    return;
  }
  
  bool success = webSocket.sendBIN(fb->buf, fb->len);
  esp_camera_fb_return(fb);
  
  if (success) {
    last_frame_time = current_time;
    static int frame_count = 0;
    frame_count++;
    
    if (frame_count % 10 == 0) {
      Serial.printf("ğŸ“¹ Frame %d sent | Heap: %d bytes\n", 
                    frame_count, ESP.getFreeHeap());
    }
  } else {
    Serial.println("âŒ Failed to send frame");
  }
  
  resetWatchdog();
}

void setup() {
  Serial.begin(115200);
  delay(2000);  // Wait for serial
  
  Serial.println("\nğŸ›¡ï¸ ESP32-CAM Ultra-Safe WebSocket Streamer");
  Serial.println("ğŸ¯ Stack overflow prevention mode enabled");
  
  // Print initial memory status
  Serial.printf("ğŸ“Š Initial memory: %d bytes heap\n", ESP.getFreeHeap());
  
  // Initialize camera with multiple fallbacks
  startCamera();
  
  // Connect to WiFi with timeout
  Serial.print("ğŸ“¡ Connecting to WiFi");
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(1000);
    Serial.print(".");
    attempts++;
    resetWatchdog();
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.printf("âœ… WiFi connected! IP: %s\n", WiFi.localIP().toString().c_str());
  } else {
    Serial.println("\nâŒ WiFi connection failed");
    return;
  }
  
  // Connect to WebSocket
  connectToWebSocket();
  
  Serial.println("ğŸš€ System ready - Ultra-safe mode active!");
  Serial.printf("ğŸ“Š Final heap: %d bytes\n", ESP.getFreeHeap());
}

void loop() {
  resetWatchdog();  // Reset watchdog regularly
  
  webSocket.loop();
  
  if (websocket_connected) {
    sendCameraFrame();
  } else {
    static unsigned long last_reconnect = 0;
    if (millis() - last_reconnect > 15000) {  // Try every 15 seconds
      Serial.println("ğŸ”„ Attempting WebSocket reconnection...");
      connectToWebSocket();
      last_reconnect = millis();
    }
  }
  
  delay(100);  // Longer delay to reduce load
}
/*
 * ESP32-C3 Super Mini - UDP Client with Auto-Discovery
 * Automatically finds server IP via broadcast discovery
 */

#include <WiFi.h>
#include <WiFiUdp.h>

// WiFi credentials - ONLY CHANGE THESE!
const char* ssid = "YOUR_HOTSPOT_NAME";
const char* password = "YOUR_HOTSPOT_PASSWORD";

// Server configuration - AUTO-DISCOVERED
String serverIP = "";
int serverPort = 4210;
const int discoveryPort = 4209;

// Joystick pins
#define JOY_X_PIN   0
#define JOY_Y_PIN   1
#define JOY_BTN_PIN 2

// Thresholds
#define THRESHOLD_LOW  1000
#define THRESHOLD_HIGH 3000

// UDP
WiFiUDP udp;
WiFiUDP discoveryUdp;

// Variables
int xValue = 0;
int yValue = 0;
char currentCommand = 'X';
char lastCommand = 'X';
unsigned long lastSendTime = 0;
const unsigned long SEND_INTERVAL = 50;

// Connection tracking
unsigned long lastPingTime = 0;
const unsigned long PING_INTERVAL = 5000;
bool serverFound = false;

bool discoverServer() {
  Serial.println("\n🔍 Searching for server...");
  
  discoveryUdp.begin(discoveryPort);
  
  unsigned long startTime = millis();
  const unsigned long timeout = 10000; // 10 second timeout
  
  while (millis() - startTime < timeout) {
    int packetSize = discoveryUdp.parsePacket();
    
    if (packetSize) {
      char incomingPacket[255];
      int len = discoveryUdp.read(incomingPacket, 254);
      
      if (len > 0) {
        incomingPacket[len] = 0;
        String message = String(incomingPacket);
        
        // Check if this is a server announcement
        if (message.startsWith("ESP32_SERVER:")) {
          // Parse: ESP32_SERVER:192.168.1.100:4210
          int firstColon = message.indexOf(':');
          int secondColon = message.indexOf(':', firstColon + 1);
          
          if (firstColon > 0 && secondColon > 0) {
            serverIP = message.substring(firstColon + 1, secondColon);
            serverPort = message.substring(secondColon + 1).toInt();
            
            Serial.println("✅ Server discovered!");
            Serial.print("   IP: ");
            Serial.println(serverIP);
            Serial.print("   Port: ");
            Serial.println(serverPort);
            
            discoveryUdp.stop();
            return true;
          }
        }
      }
    }
    
    delay(100);
  }
  
  discoveryUdp.stop();
  Serial.println("❌ Server discovery timeout");
  return false;
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n╔═══════════════════════════════════════╗");
  Serial.println("║   ESP32-C3 UDP Client (Joystick)     ║");
  Serial.println("║        AUTO-DISCOVERY ENABLED         ║");
  Serial.println("╚═══════════════════════════════════════╝\n");
  
  // Configure joystick
  pinMode(JOY_BTN_PIN, INPUT_PULLUP);
  analogReadResolution(12);
  
  // Connect to WiFi
  Serial.print("📡 Connecting to WiFi");
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✅ WiFi Connected!");
    Serial.print("📍 IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("📡 Signal Strength: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
  } else {
    Serial.println("\n❌ WiFi Connection Failed!");
    Serial.println("⚠️  Check SSID and password, then restart");
    while(1) delay(1000);
  }
  
  // Auto-discover server
  Serial.println("\n🔍 Starting auto-discovery...");
  
  for (int retry = 0; retry < 3; retry++) {
    if (discoverServer()) {
      serverFound = true;
      break;
    }
    
    if (retry < 2) {
      Serial.println("   Retrying in 2 seconds...");
      delay(2000);
    }
  }
  
  if (!serverFound) {
    Serial.println("\n❌ Could not find server!");
    Serial.println("⚠️  Make sure Python server is running");
    Serial.println("⚠️  Waiting 30 seconds before restart...");
    delay(30000);
    ESP.restart();
  }
  
  // Start UDP
  udp.begin(serverPort);
  Serial.println("✅ UDP Client started");
  
  Serial.println("\n🎮 Ready to send commands!\n");
  Serial.println("───────────────────────────────────────");
  
  // Initial ping
  sendPing();
}

void sendPing() {
  if (serverIP.length() > 0) {
    udp.beginPacket(serverIP.c_str(), serverPort);
    udp.print("PING_C3");
    udp.endPacket();
  }
}

void sendCommand(char cmd) {
  if (serverIP.length() == 0) return;
  
  String message = "C3:" + String(cmd);
  
  udp.beginPacket(serverIP.c_str(), serverPort);
  udp.print(message);
  int result = udp.endPacket();
  
  if (result == 1) {
    Serial.print("📤 Sent: ");
    Serial.print(cmd);
    Serial.print(" | X:");
    Serial.print(xValue);
    Serial.print(" Y:");
    Serial.println(yValue);
  } else {
    Serial.println("❌ Send failed!");
  }
}

void loop() {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("⚠️  WiFi disconnected! Reconnecting...");
    WiFi.reconnect();
    delay(5000);
    return;
  }
  
  // Re-discover server if connection lost
  if (!serverFound || serverIP.length() == 0) {
    Serial.println("⚠️  Server lost, re-discovering...");
    if (discoverServer()) {
      serverFound = true;
    } else {
      delay(5000);
      return;
    }
  }
  
  // Send periodic ping
  if (millis() - lastPingTime > PING_INTERVAL) {
    sendPing();
    lastPingTime = millis();
  }
  
  // Read joystick
  xValue = analogRead(JOY_X_PIN);
  yValue = analogRead(JOY_Y_PIN);
  
  // Determine command
  currentCommand = 'X'; // Default: STOP
  
  if (yValue > THRESHOLD_HIGH) {
    currentCommand = 'W'; // FORWARD
  } 
  else if (yValue < THRESHOLD_LOW) {
    currentCommand = 'S'; // BACKWARD
  }
  else if (xValue < THRESHOLD_LOW) {
    currentCommand = 'A'; // LEFT
  }
  else if (xValue > THRESHOLD_HIGH) {
    currentCommand = 'D'; // RIGHT
  }
  
  // Button press
  if (digitalRead(JOY_BTN_PIN) == LOW) {
    currentCommand = 'B'; // BUTTON/STOP
  }
  
  // Send if changed or interval elapsed
  unsigned long currentTime = millis();
  bool shouldSend = false;
  
  if (currentCommand != lastCommand) {
    shouldSend = true;
  } else if (currentTime - lastSendTime >= SEND_INTERVAL) {
    shouldSend = true;
  }
  
  if (shouldSend) {
    sendCommand(currentCommand);
    lastCommand = currentCommand;
    lastSendTime = currentTime;
  }
  
  delay(10);
}
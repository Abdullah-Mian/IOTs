/*
 * ESP32 WROOM32 - ESP-NOW Receiver + L298N Motor Driver
 * Receives W/A/S/D commands from ESP32-C3
 * Controls motors via L298N
 */

#include <esp_now.h>
#include <WiFi.h>

// L298N Motor Driver Pins
// Motor A (Right Motor)
#define ENA_PIN  14   // PWM speed control for Motor A
#define IN1_PIN  27   // Direction pin 1 for Motor A
#define IN2_PIN  26   // Direction pin 2 for Motor A

// Motor B (Left Motor)
#define ENB_PIN  12   // PWM speed control for Motor B
#define IN3_PIN  25   // Direction pin 1 for Motor B
#define IN4_PIN  33   // Direction pin 2 for Motor B

// LED for status
#define LED_PIN  2

// PWM Configuration
const int pwmFreq = 1000;      // 1 KHz
const int pwmResolution = 8;   // 8-bit resolution (0-255)
const int pwmChannelA = 0;     // PWM channel for Motor A
const int pwmChannelB = 1;     // PWM channel for Motor B

// Structure to receive data
typedef struct struct_message {
  char command;      // W, A, S, D, X
  int speed;         // 0-255
  unsigned long timestamp;
} struct_message;

struct_message incomingData;

// Statistics
unsigned long packetsReceived = 0;
unsigned long lastPacketTime = 0;

// Motor control functions
void moveForward(int speed) {
  Serial.println("‚¨ÜÔ∏è  FORWARD");
  
  // Motor A forward
  digitalWrite(IN1_PIN, HIGH);
  digitalWrite(IN2_PIN, LOW);
  ledcWrite(pwmChannelA, speed);
  
  // Motor B forward
  digitalWrite(IN3_PIN, HIGH);
  digitalWrite(IN4_PIN, LOW);
  ledcWrite(pwmChannelB, speed);
}

void moveBackward(int speed) {
  Serial.println("‚¨áÔ∏è  BACKWARD");
  
  // Motor A backward
  digitalWrite(IN1_PIN, LOW);
  digitalWrite(IN2_PIN, HIGH);
  ledcWrite(pwmChannelA, speed);
  
  // Motor B backward
  digitalWrite(IN3_PIN, LOW);
  digitalWrite(IN4_PIN, HIGH);
  ledcWrite(pwmChannelB, speed);
}

void turnLeft(int speed) {
  Serial.println("‚¨ÖÔ∏è  LEFT");
  
  // Motor A forward, Motor B backward (or stopped)
  digitalWrite(IN1_PIN, HIGH);
  digitalWrite(IN2_PIN, LOW);
  ledcWrite(pwmChannelA, speed);
  
  digitalWrite(IN3_PIN, LOW);
  digitalWrite(IN4_PIN, HIGH);
  ledcWrite(pwmChannelB, speed);
}

void turnRight(int speed) {
  Serial.println("‚û°Ô∏è  RIGHT");
  
  // Motor A backward (or stopped), Motor B forward
  digitalWrite(IN1_PIN, LOW);
  digitalWrite(IN2_PIN, HIGH);
  ledcWrite(pwmChannelA, speed);
  
  digitalWrite(IN3_PIN, HIGH);
  digitalWrite(IN4_PIN, LOW);
  ledcWrite(pwmChannelB, speed);
}

void stopMotors() {
  Serial.println("üõë STOP");
  
  // Stop both motors
  digitalWrite(IN1_PIN, LOW);
  digitalWrite(IN2_PIN, LOW);
  ledcWrite(pwmChannelA, 0);
  
  digitalWrite(IN3_PIN, LOW);
  digitalWrite(IN4_PIN, LOW);
  ledcWrite(pwmChannelB, 0);
}

// Callback when data is received
void OnDataRecv(const uint8_t *mac, const uint8_t *data, int len) {
  memcpy(&incomingData, data, sizeof(incomingData));
  
  packetsReceived++;
  unsigned long currentTime = millis();
  unsigned long latency = currentTime - incomingData.timestamp;
  
  // Visual feedback
  digitalWrite(LED_PIN, HIGH);
  
  // Print received command
  Serial.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.print("‚ïë üì• Command: ");
  Serial.print(incomingData.command);
  Serial.print(" | Speed: ");
  Serial.print(incomingData.speed);
  Serial.println("      ‚ïë");
  Serial.print("‚ïë ‚è±Ô∏è  Latency: ");
  Serial.print(latency);
  Serial.println(" ms                 ‚ïë");
  Serial.print("‚ïë üìä Packets: ");
  Serial.print(packetsReceived);
  Serial.println("                    ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  
  // Execute motor command
  switch(incomingData.command) {
    case 'W':
      moveForward(incomingData.speed);
      break;
    case 'S':
      moveBackward(incomingData.speed);
      break;
    case 'A':
      turnLeft(incomingData.speed);
      break;
    case 'D':
      turnRight(incomingData.speed);
      break;
    case 'X':
    default:
      stopMotors();
      break;
  }
  
  Serial.println();
  
  lastPacketTime = currentTime;
  
  // Turn off LED
  digitalWrite(LED_PIN, LOW);
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë  ESP32 WROOM32 L298N Motor Control   ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
  
  // Configure LED
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  
  // Configure motor control pins
  pinMode(IN1_PIN, OUTPUT);
  pinMode(IN2_PIN, OUTPUT);
  pinMode(IN3_PIN, OUTPUT);
  pinMode(IN4_PIN, OUTPUT);
  
  // Setup PWM channels
  ledcSetup(pwmChannelA, pwmFreq, pwmResolution);
  ledcSetup(pwmChannelB, pwmFreq, pwmResolution);
  
  // Attach PWM channels to pins
  ledcAttachPin(ENA_PIN, pwmChannelA);
  ledcAttachPin(ENB_PIN, pwmChannelB);
  
  // Stop motors initially
  stopMotors();
  
  Serial.println("‚úÖ Motor driver initialized");
  
  // Set device as WiFi Station
  WiFi.mode(WIFI_STA);
  
  // Print MAC Address
  Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë         IMPORTANT: COPY THIS!        ‚ïë");
  Serial.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
  Serial.print("‚ïë üìç WROOM32 MAC: ");
  Serial.print(WiFi.macAddress());
  Serial.println("  ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  Serial.println("\n‚ö†Ô∏è  Copy the MAC address above and update");
  Serial.println("   the receiverMAC[] in your C3 code!\n");
  
  // Initialize ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("‚ùå ESP-NOW Init Failed!");
    ESP.restart();
  }
  
  Serial.println("‚úÖ ESP-NOW Initialized");
  
  // Register receive callback
  esp_now_register_recv_cb(OnDataRecv);
  
  Serial.println("‚úÖ Receive callback registered");
  Serial.println("\nüéÆ Waiting for commands...\n");
  Serial.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
}

void loop() {
  // Auto-stop if no packets received for 2 seconds
  if (packetsReceived > 0 && (millis() - lastPacketTime > 2000)) {
    stopMotors();
    Serial.println("‚ö†Ô∏è  Connection lost - Motors stopped!");
    delay(1000); // Prevent spam
    lastPacketTime = millis();
  }
  
  delay(100);
}